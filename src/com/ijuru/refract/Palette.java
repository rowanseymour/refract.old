////////////////////////////////////////////////////////////////////////////
//
// Copyright 2006 Rowan Seymour
//
// This file is part of Refract.
// 
// Refract is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
// 
// Refract is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Foobar; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//
 
package com.ijuru.refract;
 
import java.awt.image.DirectColorModel;

/**
 * Palette class used to generate an array of interpolated color values
 */
public class Palette
{
	/**
	 * Palettes generated by this class use the RGB model which differs from the AWTs default
	 * sRGB model which includes alpha
	 */
	public static final DirectColorModel MODEL = new DirectColorModel(32, 0x00FF0000, 0x0000FF00, 0x000000FF); 
	
	public static Object[] SUNSET = {
		0x640032, 0.0f,
		0xFF0000, 0.3f,
		0xFFFF00, 1.0f				
	};
		
	public static Object[] HUBBLE = {
		0x0D1C40, 0.0f,
		0x46787A, 0.4f,
		0xFFFF00, 1.0f				
	};
	
	public static Object[] RAINBOW = {
		0xFF0000, 0.0f,		
		0xFF8000, 0.143f,
		0xFFFF00, 0.286f,
		0x00FF00, 0.429f,
		0x00FFFF, 0.571f,
		0x0080FF, 0.714f,
		0x0000FF, 0.857f,
		0xFF0000, 1.0f					
	};
	
	public static Object[] CHROME = {
		0x2989CC, 0.0f,		
		0xFFFFFF, 0.49f,
		0x906A00, 0.5f,
		0xD99F00, 0.625f,
		0xFFFFFF, 1.0f					
	};
	
	public static Object[] EVENING = {
		0x002874, 0.0f,		
		0xFD7C00, 0.333f,
		0x6F156C, 0.666f,
		0xF9E600, 1.0f					
	};
	
	public static Object[] ELECTRIC = {
		0x000010, 0.0f,
		0x1000F0, 0.3f,
		0xFFFFFF, 1.0f				
	};	
	
	private int[] colors = null;	
	private float[] anchors = null;
	
	/**
	 * Constructor
	 */
	public Palette(Object[] pairs)
	{
		int npairs = pairs.length / 2;
		colors = new int[npairs];
		anchors = new float[npairs];
		
		for (int p = 0; p < npairs; ++p) {
			colors[p] = (Integer)pairs[2 * p];
			anchors[p] = (Float)pairs[2 * p + 1];			
		}	
	}	
	
	/**
	 * Constructor
	 */	
	public Palette(int[] colors, float[] anchors)
	{
		if (colors.length != anchors.length)
			throw new IllegalArgumentException();
			
		this.colors = colors;
		this.anchors = anchors;		
	}
	
	/**
	 * Creates an array of RGB values by interpolating the colors in this palette
	 */	
	public int[] createInterpolation(int size)
	{		
		int[] palette = new int[size];
		
		int index = -1;	
		
		for (int i = 0; i < size; ++i) {
			float ipos = (float)i / (size - 1); // palette index 0.0...1.0
			
			if ((index < anchors.length - 1) && (ipos > anchors[index + 1]))
				++index;
				
			if (index < 0) {
				palette[i] = colors[0];
			}
			else if (index >= colors.length - 1) {
				palette[i] = colors[colors.length - 1];				
			}
			else {
				float segment_min = anchors[index];	
				float segment_max = anchors[index + 1];							
				float segment_len = segment_max - segment_min;
				float weight2 = (ipos - segment_min) / segment_len;
				float weight1 = 1.0f - weight2;
				
				int r = (int)(weight1 * getRValue(colors[index]) + weight2 * getRValue(colors[index + 1]));
				int g = (int)(weight1 * getGValue(colors[index]) + weight2 * getGValue(colors[index + 1]));			
				int b = (int)(weight1 * getBValue(colors[index]) + weight2 * getBValue(colors[index + 1]));		
				
				palette[i] = makeRGB(r, g, b);	
			}			
		}
		return palette;
	}
	
	public void invert()
	{
		for (int i = 0; i < colors.length; ++i)
			colors[i] = invertRGB(colors[i]);
	}
	
	public void reverse()
	{
		int[] newColors = new int[colors.length];
		for (int i = 0; i < colors.length; ++i)
			newColors[i] = colors[(colors.length - 1) - i];
		
		colors = newColors;
	}	
	
	/**
	 * Returns the red component of a RGB value
	 */
	private static int getRValue(int rgb)
	{
		return (rgb >> 16);
	}	
		
	/**
	 * Returns the green component of a RGB value
	 */	
	private static int getGValue(int rgb)
	{
		return (rgb >> 8) & 0x0000FF;		
	}
	
	/**
	 * Returns the blue component of a RGB value
	 */		
	private static int getBValue(int rgb)
	{
		return rgb & 0x0000FF;		
	}
	
	/**
	 * Constructs an RGB value from the 3 components
	 */	
	private static int makeRGB(int r, int g, int b)
	{
		return ((r << 16) | (g << 8) | b);
	}
	
	/**
	 * Inverts an RGB value
	 */	
	private static int invertRGB(int rgb)
	{
		return makeRGB(255 - getRValue(rgb), 255 - getGValue(rgb), 255 - getBValue(rgb));
	}
}
